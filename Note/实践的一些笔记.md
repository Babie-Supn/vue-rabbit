## 设计路由规则

**设计首页和登录页的路由（一级路由）**

路由设计原则：找内容切换的区域，如果是<span style="color:red">页面整体切换</span>，则为一级路由

**设计分类页和默认 Home 页路由（二级路由）**

路由设计原则：找内容切换的区域，如果是在<span style="color:red">一级路由页的内部切换</span>，则为二级路由

### 默认二级路由如何进行设置？

path 配置项置空

## 后端接口渲染一级路由导航

实现步骤：

1. 根据接口文档封装接口函数
2. 发送请求获取数据列表
3. v-for 渲染页面

### 吸顶交互

要求：浏览器在上下滚动的过程中，如果距离顶部的滚动距离大于 xx px，吸顶导航显示，小于 xx px 隐藏  
`准备吸顶导航`--->`获取滚动距离`--->`以滚动距离做判断条件控制组件盒子展示隐藏`

## 一些技巧

- 当有相同的数据需要重复向后端请求时，这样会降低性能，就可以使用 pinia，将需要多次请求的数据，存放在 store 文件里，在一些公共的入口文件（或父组件里进行数据请求，然后其他需要该数据的组件就可以直接使用 store 里的数据，就不需要重新请求
- 电商网站的首页通常会很长，用户不一定能访问到**页面靠下的图片**，那么这类图片通过懒加载优化手段可以做到**只有进入视口区域才发生图片请求**
- 分页功能实现较麻烦，但有对应的 UI 组件库，可以快速实现分页功能

```html
<el-pagination
  background
  layout="prev, pager, next"
  :total="total"
  :page-size="params.pageSize"
/>
```

**banner 轮播图**

轮播图实现流程：`准备模板`--->`熟悉elementPlus相关组件`--->`获取接口数据`--->`渲染组件`

**面板组件封装**

组件封装解决什么问题？

- 1. 复用问题
- 2. 业务维护问题

有一些组件结构上基本相同，只是内容的差别，这时候就可以将可复用的组件结构封装  
核心思路：把可复用的结构只写一次，把可能<span style="color:red">发生变化的部分抽象成组件参数（props/插槽）</span>

实现步骤：

1. 不做任何抽象，准备静态模板
2. 抽象可变的部分
   - 主标题和副标题的纯文本，可以抽象成 prop 传入
   - 主体内容是复杂的模板，抽象成插槽传入

**纯展示类组件通用封装思路总结：**

1. 搭建纯静态的部分，不管可变的部分
2. 抽象可变的部分为组件参数
   - 非复杂的模板抽象成 props，复杂的结构模版抽象为插槽

**在创建单页面项目时，会遇到路由缓存问题，什么是路由缓存问题？**

- 例如：使用带参数的路由时需要注意的是，当用户从`/users/kate`导航到`/users/mike`时，相同的组件实例也将被复用，因为两个路由都渲染同个组件，比起销毁再重建，复用会更高效，但是这也导致新的数据不会被渲染，造成页面不更新，即意味着组件的生命周期钩子不会被调用

解决问题的思路：

- 1. 让组件不复用，强制销毁重建（很粗暴，会将组件所有的数据都重新发送请求）

  ```html
  <!-- 方案一：给RouterView添加key 
        以当前路由完整路径为key的值，给router-view组件绑定
   -->
  <RouterView :key="$route.fullPath" />
  <!-- 最常见的就是与v-for结合 -->
  <ul>
    <li v-for="xxx" :key="$route.fullPath">...</li>
  </ul>
  也可以用于强制替换一个元素/组件而不是复用它， 当你想这么做时它可能会很有用： *
  在适当的时候触发组件的生命周期钩子 * 触发过渡
  ```

- 2. 监听路由变化，变化之后进行数据更新

**方案二：使用 beforeRouteUpdate 导航钩子**

- beforeRouteUpdate 钩子函数可以在每次路由更新之前执行，在**回调中执行需要数据更新的业务逻辑**即可
- 或者，使用`beforeRouteUpdate`导航守卫，它也可以取消导航

```js
const User = {
  template: "xxx",
  async beforeRouteUpdate(to, from) {
    //对路由变化做出响应。。。
    this.userData = await fetchUser(to.params.id);
  },
};
```

小总结：

- 在意性能选方案二，精准控制请求内容，精细化控制
- 不在意性能选方案一，选择 key，简单粗暴

## 使用逻辑函数拆分业务

- 基于逻辑函数拆分业务是指把<sapn style="color:red">同一个组件中独立的业务代码通过函数做封装处理</span>，提升代码的可维护性

**具体怎么做？**

实现步骤：

1. 按照业务声明以'use'打头的逻辑函数
2. 把独立的业务逻辑封装到各个函数内部
3. 函数内部把组件中需要用到的数据或者方法 return 出去
4. 在组件中调用函数把数据或者方法组合回来使用

**在对列表实现瀑布加载的时候，监听是否滚动到底部时，可以使用:**

- `ElementPlus`提供的`v-infinite-scroll`指令实现底部监听，只需要将该指令添加到需要渲染的列表里，并`v-infinite-scroll="load"`，这样添加一个 load 方法，这样每次加载到底部时，会执行 load 方法

**放大镜效果实现-滑块跟随鼠标**

- 利用`vueuse`的`useMouseInElement`,控制滑块跟随鼠标移动

**总结：**

1. 封装复杂交互组件的通用思路
   - `功能拆解`->`寻找核心实现思路`->`寻找关键技术`->`逐个实现，逐个验证，最后逐个优化`
2. 例如：图片预览组件的封装逻辑
   - `1.小图切换大图显示；2.放大镜实现`->`获取鼠标相对位移，操作滑块left/top`->`useMouseInElement`->`验证优化`

## SKU 的概念

存货单位（stock keeping unit），也翻译为库存单元，是一个会计学名词，定义为<span style="color:red">库存管理中的最小可用单元</span>，例如纺织品中一个 SKU 通常表示规格、颜色、款式，而在连锁零售门店中有时称单品为一个 SKU

SKU 组件的作用：<span style="color:red">产出当前用户选择的商品规格</span>，为加入购物车提供数据信息

**问**：在实际工作中，经常会遇到别人写好的组件，熟悉一个三方组件，首先重点看什么？  
**答**：props 和 emit，**props 决定了当前组件接收什么数据，emit 决定了会产出什么数据**
即 props 管入参，emit 管出参

**如果有通用型组件，而且有可能在多个业务模块中共享，就可以统一进行全局组件注册**

## 表单如何校验

`ElementPlus`表单组件内置了表单校验功能，只需要按照组件要求配置必要参数即可（直接看文档），应付简单的校验只需要通过配置即可，如果想要定制一些特殊的校验需求，可以使用**自定义校验规则**
**格式如下**：

```js
{
  validator: (rule, val, callback) => {
    //自定义校验逻辑
    //value：当前输入的数据
    //callback：校验处理函数，校验通过调用
  };
}
```

**持久化用户数据说明**

1. 用户数据中有一个关键的数据叫做<span style="color:red">Token(用来标识当前用户是否登录)</span>，而 Token 会持续一段时间才会过期
2. Pinia 的存储是基于内存的，刷新就丢失，为了保持登录状态就要做到刷新不丢失，需要配合持久化进行存储

目的：保持 Token 不丢失，保持登录状态  
最终效果：操作 state 时会自动把用户数据在本地的 localStorage 也存一份，刷新的时候会从 localStoorage 中先取

## 为什么要在请求拦截器携带 Token？

- Token 作为用户标识，在很多个接口中都需要携带 Token 才可以正确获取数据，所以需要在接口调用时携带 Token。另外，为了统一控制采取请求拦截器携带的方案
  - 通常 Token 数据会被注入到请求 header 中，格式按照后端要求的格式进行拼接处理

注：useRouter 只能在组件内使用，在单独的 js 或 ts 中不能直接使用，因此可以使用写好的路由配置文件

## 购物车实现

购物车是一个比较复杂的业务，在实际过程中可以分为本地购物车（未登录状态）和接口购物车（登录状态），就可以对业务进行拆分，用 pinia 管理数据，以及持久化缓存

**列表购物车-单选功能**

**核心思路**：单选的核心思路就是始终把<span style="color:red">单选框的状态和 pinia 中 store 对应的状态保持同步</span>  
**注意事项**：v-model 双向绑定指令不方便进行命令式的操作（因为后续还需要调接口），所以把 v-model 回退到一般模式，也就是：<span style="color:red">model-value 和@change 的配合实现</span>

**地址激活交互实现**

原理：地址切换是我们经常遇到的`tab切换类`需求，这类需求的实现逻辑都是相似的

1. 点击时记录一个当前激活地址对象 activeAddress，点击哪个地址就把哪个地址对象记录下来
2. 通过动态类名：class 控制激活样式类型 active 是否存在，判断条件为：激活地址对象的 id === 当前项 id
